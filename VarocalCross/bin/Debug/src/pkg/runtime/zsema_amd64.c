// auto generated by go tool dist
// goos=darwin goarch=amd64

#include "runtime.h"
#include "arch_GOARCH.h"

#line 3013 "C:\Go\src\pkg\runtime\sema.goc"
typedef struct Sema Sema; 
struct Sema 
{ 
uint32 volatile *addr; 
G *g; 
Sema *prev; 
Sema *next; 
} ; 
#line 3022 "C:\Go\src\pkg\runtime\sema.goc"
typedef struct SemaRoot SemaRoot; 
struct SemaRoot 
{ 
Lock; 
Sema *head; 
Sema *tail; 
#line 3029 "C:\Go\src\pkg\runtime\sema.goc"
uint32 volatile nwait; 
} ; 
#line 3033 "C:\Go\src\pkg\runtime\sema.goc"
#define SEMTABLESZ 251 
#line 3035 "C:\Go\src\pkg\runtime\sema.goc"
static union 
{ 
SemaRoot; 
uint8 pad[CacheLineSize]; 
} semtable[SEMTABLESZ]; 
#line 3041 "C:\Go\src\pkg\runtime\sema.goc"
static SemaRoot* 
semroot ( uint32 *addr ) 
{ 
return &semtable[ ( ( uintptr ) addr >> 3 ) % SEMTABLESZ]; 
} 
#line 3047 "C:\Go\src\pkg\runtime\sema.goc"
static void 
semqueue ( SemaRoot *root , uint32 volatile *addr , Sema *s ) 
{ 
s->g = g; 
s->addr = addr; 
s->next = nil; 
s->prev = root->tail; 
if ( root->tail ) 
root->tail->next = s; 
else 
root->head = s; 
root->tail = s; 
} 
#line 3061 "C:\Go\src\pkg\runtime\sema.goc"
static void 
semdequeue ( SemaRoot *root , Sema *s ) 
{ 
if ( s->next ) 
s->next->prev = s->prev; 
else 
root->tail = s->prev; 
if ( s->prev ) 
s->prev->next = s->next; 
else 
root->head = s->next; 
s->prev = nil; 
s->next = nil; 
} 
#line 3076 "C:\Go\src\pkg\runtime\sema.goc"
static int32 
cansemacquire ( uint32 *addr ) 
{ 
uint32 v; 
#line 3081 "C:\Go\src\pkg\runtime\sema.goc"
while ( ( v = runtime·atomicload ( addr ) ) > 0 ) 
if ( runtime·cas ( addr , v , v-1 ) ) 
return 1; 
return 0; 
} 
#line 3087 "C:\Go\src\pkg\runtime\sema.goc"
void 
runtime·semacquire ( uint32 volatile *addr ) 
{ 
Sema s; 
SemaRoot *root; 
#line 3094 "C:\Go\src\pkg\runtime\sema.goc"
if ( cansemacquire ( addr ) ) 
return; 
#line 3103 "C:\Go\src\pkg\runtime\sema.goc"
root = semroot ( addr ) ; 
for ( ;; ) { 
runtime·lock ( root ) ; 
#line 3107 "C:\Go\src\pkg\runtime\sema.goc"
runtime·xadd ( &root->nwait , 1 ) ; 
#line 3109 "C:\Go\src\pkg\runtime\sema.goc"
if ( cansemacquire ( addr ) ) { 
runtime·xadd ( &root->nwait , -1 ) ; 
runtime·unlock ( root ) ; 
return; 
} 
#line 3116 "C:\Go\src\pkg\runtime\sema.goc"
semqueue ( root , addr , &s ) ; 
g->status = Gwaiting; 
g->waitreason = "semacquire" ; 
runtime·unlock ( root ) ; 
runtime·gosched ( ) ; 
if ( cansemacquire ( addr ) ) 
return; 
} 
} 
#line 3126 "C:\Go\src\pkg\runtime\sema.goc"
void 
runtime·semrelease ( uint32 volatile *addr ) 
{ 
Sema *s; 
SemaRoot *root; 
#line 3132 "C:\Go\src\pkg\runtime\sema.goc"
root = semroot ( addr ) ; 
runtime·xadd ( addr , 1 ) ; 
#line 3138 "C:\Go\src\pkg\runtime\sema.goc"
if ( runtime·atomicload ( &root->nwait ) == 0 ) 
return; 
#line 3142 "C:\Go\src\pkg\runtime\sema.goc"
runtime·lock ( root ) ; 
if ( runtime·atomicload ( &root->nwait ) == 0 ) { 
#line 3146 "C:\Go\src\pkg\runtime\sema.goc"
runtime·unlock ( root ) ; 
return; 
} 
for ( s = root->head; s; s = s->next ) { 
if ( s->addr == addr ) { 
runtime·xadd ( &root->nwait , -1 ) ; 
semdequeue ( root , s ) ; 
break; 
} 
} 
runtime·unlock ( root ) ; 
if ( s ) 
runtime·ready ( s->g ) ; 
} 
void
sync·runtime_Semacquire(uint32* addr)
{
#line 3161 "C:\Go\src\pkg\runtime\sema.goc"

	runtime·semacquire(addr);
}
void
sync·runtime_Semrelease(uint32* addr)
{
#line 3165 "C:\Go\src\pkg\runtime\sema.goc"

	runtime·semrelease(addr);
}
